float4x4 worldViewProj;
texture texture0;
float3 ambientLightColor;
float3 lightPos;
float3 attenuation;
float3 lightColor;
float3 fogColor;

sampler2D texSampler0 : TEXUNIT0 = sampler_state
{
    Texture	  = (texture0);
    MIPFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MINFILTER = LINEAR;
};

struct VS_INPUT
{
	float3 position  : POSITION;
	float2 tex       : TEXCOORD0;
	float3 normal    : NORMAL;
	float3 tangent   : TANGENT;
};	

struct VS_OUTPUT
{
	float4 position  : POSITION;
	float2 tex       : TEXCOORD0;
	float2 distance  : TEXCOORD1;
	float4 pos       : TEXCOORD2;
};

struct PS_OUTPUT
{
	float4 color     : COLOR0;
};

VS_OUTPUT vs_main(VS_INPUT IN)
{
	VS_OUTPUT OUT;
	
	float4 vec = float4(IN.position, 1);
	
	OUT.position = mul(worldViewProj, vec);
	OUT.pos = OUT.position;
	OUT.tex = IN.tex;
	OUT.distance = lightPos - IN.position;

	return OUT;
}

PS_OUTPUT ps_main(VS_OUTPUT IN)
{
	PS_OUTPUT OUT;
	
	float dist = sqrt(IN.distance.x*IN.distance.x + IN.distance.y*IN.distance.y);
	
	float atten = 1.0f / (attenuation.x + attenuation.y * dist + attenuation.z * dist * dist);
	
	float3 attenLightColor = (lightColor * atten);
	float4 baseColor = tex2D(texSampler0, IN.tex);

	OUT.color.rgb = (ambientLightColor + attenLightColor) * baseColor.rgb;
	OUT.color.a = baseColor.a;
	
	//OUT.color.rgb = (1 - IN.pos.z) * OUT.color.rgb + IN.pos.z * fogColor;

	return OUT;
}



technique Lighting
{
   pass Pass_0
   {
      AlphaBlendEnable = TRUE;
      
      VertexShader = compile vs_2_0 vs_main();
      PixelShader = compile ps_2_0 ps_main();
   }
}

